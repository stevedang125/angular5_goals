1. Data binding, Two ways data binding:

2.  app.component.html

      <app-home [propertyGoal]="goal" (customEvent)="customFunction($event)" ></app-home>

      <!-- @Output custom event binding: -->

              <!-- (customEvent)="customFunction($event)" -->

              <!-- ****************** SUPER IMPORTAN part: ********************************* -->
              <!-- the HomeComponent will need to add these in home.component.ts/export class
              import { Component, OnInit , Input, Output, EventEmitter } from '@angular/core';
              @Output() customEvent = new EventEmitter();
              fireTheCustomEvent(e) this is a (click)="fireTheCustomEvent($event)" for the view
                {
                  this.customEvent.emit(e);
                }

              -->
              <!-- ******************************************************************* -->

              <!-- <button (click)="fireTheCustomEvent($event)" >Click me !</button> -->

      <!-- @Input custom property binding: -->

              <!-- [custom Property] = "object/model in component.ts"  -->
              <!-- => [propertyGoal]="goal" -->

              <!-- passing the data in the object "goal" into [propertyGoal]
              so the HomeComponent can get the data out of this [propertyGoal] -->

              <!-- ****************** SUPER IMPORTAN part: ********************************* -->
              <!-- the HomeComponent will need to add these in home.component.ts/export class
              import { Component, OnInit , Input} from '@angular/core';
              @Input() propertyGoal; -->
              <!-- ******************************************************************* -->

              <!-- in the HomeComponent's view, use propertyGoal to access object goal variables -->

3. Setting up route(app.module.ts, app.component.ts)
  Step 1: import the library for route, create routes, import RouterModule.forRoot(appRoutes) into import:[]
  Step 2: import route to app.component.ts import { RouterModule, Routes } from '@angular/router';
  Step 3: use <route_outlet></route_outlet> tag in the app view

  import { RouterModule, Routes } from '@angular/router';
  const appRoutes: Routes = [
    { path: 'directory', component: DirectoryComponent },
    { path: '', component: HomeComponent },
    { path: '**', redirectTo: '', pathMatch: 'full' }
  ];
    imports: [
      BrowserModule,
      FormsModule,
      RouterModule.forRoot(appRoutes)
    ],;


4. After some css fun, add links to the nav bar: [routerLink]="['/pathInHere']"

   by using routerLink from Angular, so fast, yes so efficient <3
   <li> <a [routerLink]="['/']">Home</a> </li>
   <li> <a [routerLink]="['/directory']">Directory</a> </li>

5. Route Params: (import ActivatedRoute from angular/router in app.module.ts)

  import the ActivatedRoute library to the root app.module.ts and
  the component you want to get the route params(this case directory.component.ts)
  and into the constructor
        constructor(private route: ActivatedRoute)
        {
          this.return_id = route.snapshot.params['id'];
        }

  in the path, give the params a name:( like this path: 'directory/:id')
        const appRoutes: Routes = [
          { path: 'directory/:id', component: DirectoryComponent },
          { path: '', component: HomeComponent },
          { path: '**', redirectTo: '', pathMatch: 'full' }
        ];

  directory.component.ts

        import { ActivatedRoute } from '@angular/router';
        export class DirectoryComponent implements OnInit {
          // declare a var to assign the params to it.(return_id in this case)
          return_id: string;

          constructor(private route: ActivatedRoute)
          {
            this.return_id = route.snapshot.params['id'];
          }
6. Directives:
  1. Definition: They are instructions that tell Angular to do some fun stuff
    Example:
      <router-outlet></router-outlet>
      [routerLink]= "['/path']"
  2. Types of Directive:
  a) Attribute: expects an object in ""
      Interact with the element it's on to change it's properties
      Eg: ngClass expects an object so
          [ngClass]="{'object': true, 'object': true,'andmore': true}"


      [ngStyle]="{background: object.item}"

          in the component.ts file, if we declared an object like this:
          classes = {'blue': true, 'red': true, 'underline': true};
          <p [ngClass]="classes">
          simply pass the object ^^

  b) Structure:
      Change the structure of the HTML code: (my favvvvvvv :D)
      Eg: *ngIf="true/false" or a Boolean variable
       test = true; in component, then *ngIf="test"

7. *ngFor? for loop !!! yess
  1. cycle through a list and put the item out to the view.
   Eg: <li *ngFor="let x in list"></li> (list: collection of objects)
   {{x.item_from_list}}
   {{x.item1_from_list}}
   {{x.item2_from_list}}
 2. this will loop through an ARRAY, so in component:
 goals = [
  {small:  "Summer Internship.", big: "Full stack web dev. at Universal Studios.", color: "Green" },
  {small:  "Maintain good grades !", big: "MIT", color: "Blue" },
  {small:  "Be more healthy.", big: "Get buff", color: "Red" }
 ]

8. Pipes and Custom Pipes:
  1a) String: Built in:(uppercase, lowercase, slice:start:stop) (stop - start = how many letters you want.)

                put pipe | after the data you want to output to the view/template
                Eg:   {{goal.small | uppercase}} {{goal.color | slice:1:3}}
                      slice takes parameters: {{goal.color | slice:1}} => "Green" to "_ r e e n"
                                              {{goal.color | slice:1:3}} => "Green" to "_ r e _ _ _"
                      what about 3 params? {{goal.color | slice:1:3:5}} => it didn't work =))

                Eg:   2 pipes at once!
                      {{goal.big | lowercase | slice:1:3}}

                Eg: <label>Test json pipe: </label><span>{{goal | json}}</span>
                   => { "small": "Summer Internship.", "big": "Full stack web dev.
                    at Universal Studios.", "color": "Green" }
                    <span>{{goal.small | titlecase}}</span>
  1b)  Number: Built in(number:'1.2-3', percent, currency, currency: 'GBP')
            Eg: {{ 5.678 | number:'1.2-3' }} => 5.678
                {{ .25 | percent }} => 25%
                {{ .25 | currency }} => $.25
                {{ .25 | currency: 'EUR':code }} =>Euro.25

  1c)  Date: (date:short,middium,longDate)
             component.ts: public date = new Date();
             template:
                {{ date | date:'short' }} => 03/03/2799, 1:00 AM, to the future
                {{ date | date:'shortDate' }} => 03/03/2799
                {{ date | date:'shortTime' }} => 1:00 AM


  2) Custom (yay): filter.pipe.ts,ng g piple <custom_pipe_name>

          in project_name/src/app run: ng g piple <custom_pipe_name>
          Eg:  {{goal.big | custom_pipe_name}}

          in filter.pipe.ts:
                    name  type  (this is what you called in the view, "term")
          transform(value: any, args?: any): any {
            return null;
          }
          either this true/false,
                  export class FilterPipe implements PipeTransform {
                    transform(goals: any, term: any): any {
                      // Check if search term is undefined
                      if(term === undefined) return goals;
                      // return updated goals array
                      return goals.filter(function(return_val){
                        return return_val.small.toLowerCase().includes(term.toLowerCase());
                    })
          if term is match, return_val would hold that and get return back to the view
          if not just return the whole array

    Custom Filter Part2:
        * in src/app create the filter.pipe.ts by ng g pipe filter
            import { Pipe, PipeTransform } from '@angular/core';

            @Pipe({
              name: 'filter'
            })

        * taking in an array: goals
          taking in a search key: term
          using the filter(check if the term is match or not)
          if true: return it to the view.

            transform(goals: any, term: any): any {
              // Check if search term is undefined
              if(term === undefined) return goals;
              // return updated goals array
              return goals.filter(function(return_val){
                return return_val.color.toLowerCase().includes(term.toLowerCase());
            })
            }


        * in the view:
          <input type="text" [(ngModel)] = "term"> // two ways binding heyyyyy
          <li *ngFor="let goal of goals | filter:term"> // use the custom filter

        * in the component:
         initialize the variable to be change, in this case: term: string;

9.   Services: injected individually: (providers)
     With angular 5, the service is added automatically to the
     app.module using this command: ng g s -m app.moduleï»¿

        Component1 : Do this ----\
                                  |>----- both do one same job A connect to the data
        Component2: Do that -----/
        => don't duplicate your code because that'll be more work load;
        => update and maintain would be bad >__<

        * generate a services component: ng g s logging, this will be the logging service
          the logic in logging.service.ts will get injected into home, directory components,
          whichever component that need to use the service

        * component.ts:
          import { LoggingService } from '../logging.service';
          constructor(private logger: LoggingService)
          providers: [ LoggingService ]
          create a method listen to a click event in the view
          { this.logger.<method_in_service.js>()}

        * view/template:
          event binding by (click)="method()"

        * Good stuff:
          Array User: {{logger.users}}
